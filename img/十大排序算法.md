# 十大排序算法

##  冒泡排序

### 思路 :

​	通过对待排序序列从前向后（从下标较小的元素开始）,依次对相邻两个元素的值进行两两比较，若发现前一个数大于后一个数则交换，使值较大的元素逐渐从前移向后部，就如果水底下的气泡一样逐渐向上冒。



### 算法解释：

冒泡排序是一种简单的交换排序算法，其核心思想是通过重复遍历待排序序列，每次比较相邻的两个元素，若它们的顺序错误则进行交换，直到整个序列有序。排序过程中，较大的元素会像气泡一样逐渐 “浮” 到序列的末尾，因此得名冒泡排序。



### 适用场景：

- 数据量较小的场景，因为其时间复杂度较高，在数据量大时效率低下。
- 对排序稳定性有要求的场景，冒泡排序是稳定的排序算法（相等元素的相对位置不会改变）。
- 接近有序的数据序列，此时通过优化（如设置交换标记）可以大幅提高效率。



### 优势劣势：

- 优势：实现简单，逻辑清晰；是稳定的排序算法；对接近有序的数据排序效率较高（可提前终止）。
- 劣势：时间复杂度较高，平均和最坏情况均为 O (N²)，不适合处理大量数据。



### 数组讲解:

待排序数组：3，9，-1，10，20            list = [3, 9,- 1, 10, 20]

 **第一轮排序：**

​    （1）3，9，-1，10，20    ----3跟9比较，不交换

​    （2）3，-1，9，10，20    ----9比 -1大，所以9跟 -1交换

​    （3）3，-1，9，10，20    ----9跟10比较，不交换

​    （4）3，-1，9，10，20    ----10跟20比较，不交换

第一轮过后，将20这个最大的元素固定到了最后的位置。

在第二轮的时候20不参与冒泡。

 **第二轮排序：**

因为20的位置已经固定，所以只对前4个进行排序即可：

​    （1）-1，3，9，10，20    ----3比 -1大，进行交换

​    （2）-1，3，9，10，20    ----3跟9比较，不交换

​    （3）-1，3，9，10，20    ----9跟10比较，不交换

第二轮过后，将第二大的元素固定到了倒数第二个位置

**第三轮排序：**

10和20的位置已经确定，只需对前三个进行排序

​    （1）-1，3，9，10，20    ----3和-1比较，不交换

​    （2）-1，3，9，10，20    ----3和9比较，不交换

第三轮过后，将第三大的元素位置确定

**第四轮排序：**

只对前两个元素进行排序

​    （1）-1，3，9，10，20    ----3和-1比较，不交换

第四轮过后，将第四大的元素位置确定，此时总共5个元素，已经排序好4个，从而最后一个自然而然就是排好序的了



### 小结:

设总的元素个数为n，那么由上边的排序过程可以看出：

（1）总计需要进行（n-1）轮排序，也就是（n-1）次大循环

（2）每轮排序比较的次数逐轮减少

（3）如果发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序

（4）时间复杂度是O(N^2)    在有序的时候，很快，因为有exchange变量优化了代

 在乱序的时候很慢很慢。





### 总结:

![image-20250904150921655](./assets/image-20250904150921655.png)



### **示例图:**

![img](./assets/bfe2e655008710a852274f86240c6963.gif)



### 示例代码:

```c
#include<stdio.h>
// 交换两个整数的值
// 参数：a-指向第一个整数的指针，b-指向第二个整数的指针
void swap(int* a, int* b)
{
    int tmp = *a;  // 临时变量存储a指向的值
    *a = *b;       // 将b指向的值赋给a指向的位置
    *b = tmp;      // 将临时变量存储的原a值赋给b指向的位置
}

// 冒泡排序函数
// 参数：a-待排序数组的指针，n-数组元素个数
void BubbleSort(int* a, int n)
{
    int end = n - 1;  // 每轮排序的终点索引（初始为最后一个元素）
    while(end > 0)    // 当终点索引大于0时，继续排序（至少有两个元素需要比较）
    {
        int exchange = 0;  // 交换标记，0表示本轮未发生交换
        // 从数组起始位置遍历到end-1，比较相邻元素
        for (int i = 0; i < end; i++)
        {
            // 若当前元素大于后一个元素，交换它们（此处实现的是降序排序，若需升序可改为a[i] > a[i+1]）
            if (a[i] < a[i + 1])
            {
                swap(&a[i], &a[i + 1]);
                exchange++;  // 发生交换，标记置为1
            }
        }
        if (exchange == 0)  // 若本轮未发生交换，说明数组已有序，提前退出
            break;
        end--;  // 每轮结束后，最大元素已"冒泡"到当前end位置，下轮终点前移一位
    }
}
```

```python
# 冒泡排序  O(n^2)
def bubble_sort(list):
    n = len(list)
    # 外层循环控制排序轮次，最多需要n-1轮
    for i in range(n - 1):
        # 标记本轮是否发生过交换，初始化为True（假设已有序）
        flag = True

        # 内层循环进行相邻元素比较和交换
        # 每轮结束后，最大的元素已"冒泡"到末尾，不需要再比较
        # 因此每轮比较范围递减i个元素
        for j in range(n - i - 1):
            # 如果前一个元素大于后一个元素，交换它们
            if list[j] > list[j + 1]:
                list[j], list[j + 1] = list[j + 1], list[j]
                flag = False  # 发生了交换，修改标记

        # 如果本轮没有发生任何交换，说明列表已经有序，提前退出
        if flag:
            break

    return list


# 测试代码
if __name__ == '__main__':
    list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print("冒泡排序前: ", list)
    print("冒泡排序后: ", bubble_sort(list))

```





## 选择排序

### 思路:

1.内层循环一趟找出最小值的下标，与第一个数交换。重复找小，交换的两个操作。
2.实际上，我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。

但时间复杂度还是O（N^2），效率还是不高



### 算法解释：

选择排序的核心思想是通过遍历未排序区间，每次找出区间内的最小（或最大）元素，将其与未排序区间的第一个元素交换位置，从而使未排序区间逐渐缩短，已排序区间逐渐延长，直到整个序列有序。其本质是通过 “选择” 最小元素并 “交换” 到对应位置来实现排序。



### 适用场景：

- 数据量较小的场景，因为时间复杂度较高，不适合大规模数据。
- 对排序稳定性要求不高的场景（选择排序是不稳定排序，相等元素的相对位置可能改变）。
- 内存空间有限的场景，因为选择排序是原地排序，不需要额外的大量存储空间。



### 优势劣势：

- 优势：实现简单，逻辑直观；原地排序，空间复杂度为 O (1)；交换次数少（最多 n-1 次），适用于交换成本较高的场景。
- 劣势：时间复杂度较高，无论数据是否有序，平均和最坏情况均为 O (N²)；排序不稳定，可能改变相等元素的相对位置。





### 示例图:

![img](./assets/5d50f9a16c5bb410be12eee453d31ef2.gif)



### 总结:

![image-20250904151058786](./assets/image-20250904151058786.png)



### 示例代码:

```c
// 选择排序函数
// 参数：a-待排序数组的指针，n-数组元素个数
void SelectSort(int* a, int n)
{
    // 外层循环控制已排序区间的终点（0到i-1为已排序，i到n-1为未排序）
    // 只需循环n-1次，因为最后一个元素无需排序
    for (int i = 0; i < n-1; i++)
    {
        int min = i;  // 记录未排序区间中最小值的索引（初始假设第一个元素为最小）
        int j;
        // 内层循环遍历未排序区间，寻找最小值的索引
        for (j = i; j < n; j++)
        {
            if (a[j] < a[min])  // 若当前元素小于记录的最小值，更新最小值索引
            {
                min = j;
            }
        }
        // 将找到的最小值与未排序区间的第一个元素（a[i]）交换
        swap(&a[i], &a[min]);  // 交换函数复用冒泡排序中的swap
    }
}
```

```python
# 选择排序  O(n^2)
def select_sort(list):
    n = len(list)
    # 外层循环控制需要进行选择的轮次，共需要n-1轮
    # 每轮确定一个位置的元素（第i个位置）
    for i in range(n - 1):
        # 假设当前位置的元素是最小值，记录其索引
        min_index = i

        # 内层循环在剩余未排序元素中寻找最小值
        # 从i+1位置开始，到列表末尾
        for j in range(i + 1, n):
            # 如果找到更小的元素，更新最小值索引
            if list[j] < list[min_index]:
                min_index = j

        # 如果最小值不在当前位置，交换两个元素
        # 即将找到的最小值放到第i个位置
        if min_index != i:
            list[i], list[min_index] = list[min_index], list[i]

    return list

# 测试代码
if __name__ == '__main__':
    list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print("选择排序前: ", list)
    print("选择排序后: ", select_sort(list))

```

**python优化版:**

```python
def select_sort_optimized(arr):
    """
    优化版选择排序：每轮同时找到最大值和最小值，分别放到两端
    减少循环次数，提高效率
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    n = len(arr)
    if n <= 1:
        return arr
    
    # 左边界从0开始，右边界从末尾开始
    left = 0
    right = n - 1
    
    # 当左右边界相遇或交叉时，排序完成
    while left < right:
        # 记录本轮最大值和最小值的索引
        min_index = left
        max_index = left
        
        # 遍历当前未排序区间[left, right]
        for i in range(left, right + 1):
            # 更新最小值索引
            if arr[i] < arr[min_index]:
                min_index = i
            # 更新最大值索引
            if arr[i] > arr[max_index]:
                max_index = i
        
        # 处理特殊情况：最大值在左边界（需先处理最小值）
        if max_index == left:
            max_index = min_index  # 因为最小值会被交换到左边界
        
        # 将最小值交换到左边界
        arr[left], arr[min_index] = arr[min_index], arr[left]
        # 将最大值交换到右边界
        arr[right], arr[max_index] = arr[max_index], arr[right]
        
        # 缩小未排序区间
        left += 1
        right -= 1
    
    return arr
```



## 插入排序

### 思路:

​	在待排序的元素中，假设前n-1个元素已有序，现将第n个元素插入到前面已经排好的序列中，使得前n个元素有序。按照此法对所有元素进行插入，直到整个序列有序。
  但我们并不能确定待排元素中究竟哪一部分是有序的，所以我们一开始只能认为第一个元素是有序的，依次将其后面的元素插入到这个有序序列中来，直到整个序列有序为止。



### 算法解释：

插入排序的核心思想是将待排序序列分为 “已排序区间” 和 “未排序区间”，初始时已排序区间只有第一个元素。然后依次从无排序区间中取出元素，将其插入到已排序区间的合适位置（保证插入后已排序区间仍有序），重复此过程直到未排序区间为空，整个序列即排序完成。类似整理扑克牌时，将新抽到的牌插入到已有序的牌堆中的操作。



### 适用场景：

- 数据量较小的场景（如 n≤100），此时效率较高。
- 接近有序的数据序列，此时插入操作的比较和移动次数少，效率接近 O (n)。
- 对排序稳定性有要求的场景（插入排序是稳定排序）。
- 流式数据排序（新数据可实时插入到已排序序列中）。



### 优势劣势：

- 优势：实现简单，逻辑清晰；原地排序，空间复杂度为 O (1)；稳定排序；对接近有序或小规模数据效率高。
- 劣势：时间复杂度较高，平均和最坏情况为 O (N²)，不适合大规模无序数据。



### 举例:

如下图的插入扑克牌，当摸到7的时候，会不自觉的与前面的数比较，如果比7大，把大的数向后挪动（swap），然后在第一个小于7的后面插入7

![img](./assets/0f1657fb7d6a355cdfddc24902f52cb1.png)



### 示例图:

![img](./assets/7b23514289fd4c0fa3eeb9343a58baad.gif)



### 总结

![image-20250904150746987](./assets/image-20250904150746987.png)



### 示例代码:

```c
// 插入排序函数
// 参数：a-待排序数组的指针，n-数组元素个数
void InsertSort(int* a, int n)
{
    // 外层循环：从第二个元素开始（索引1），依次作为待插入元素
    // 因为第一个元素（索引0）可视为初始有序区间
    for (int i = 1; i < n; i++)
    {
        // 若当前元素（待插入）小于前一个元素，说明需要插入到前面的有序区间
        // 若大于等于，则无需操作（已在正确位置）
        if (a[i] < a[i - 1])
        {
            int tmp = a[i];  // 暂存待插入元素的值
            int j;
            // 内层循环：从有序区间的末尾（i-1）向前遍历，寻找插入位置
            // 当元素大于待插入值时，向后移动该元素
            for (j = i - 1; j >= 0 && a[j] > tmp; j--)
            {
                a[j + 1] = a[j];  // 元素后移，为待插入元素腾出位置
            }
            // 循环结束后，j+1即为插入位置，放入待插入元素
            a[j + 1] = tmp;
        }
    }
}
// 两次循环实现：外层控制待插入元素，内层完成插入操作
```

```python
# 折半插入排序   O(n^2)
def insert_sort(list):
    list = [0] + list
    n = len(list)
    for i in range(2, n):  # 依次将A[2]～A[n]插入前面的已排序序列
        list[0] = list[i]  # 将A[i]暂存到A[0]
        low = 1
        high = i - 1  # 设置折半查找的范围
        while low <= high:  # 折半查找（默认递增有序）
            mid = (low + high) // 2  # 取中间点
            if list[mid] > list[0]:
                high = mid - 1  # 查找左半子表
            else:
                low = mid + 1  # 查找右半子表
        for j in range(i - 1, low - 1, -1):
            list[j + 1] = list[j]  # 统一后移元素，空出插入位置
        list[low] = list[0]  # 插入操作
    return list[1:]


# 测试代码
if __name__ == '__main__':
    list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print(insert_sort(list))
    print("插入排序前: ", list)
    print("插入排序后: ", insert_sort(list))

```





## 希尔排序

### 思路:

1.插入排序的优化版，有一个预排序的过程。让大的数快速的跳到后面，小的数快速的跳到前面。

2.使待排序列接近有序，然后再对该序列进行一次插入排序。

3.相当于把直接插入排序中的1换成gap而已。 



### 算法解释：

希尔排序（又称缩小增量排序）是插入排序的改进版本，其核心思想是通过设置一个 “增量 gap”，将原序列分割为若干个间隔为 gap 的子序列，对每个子序列分别进行插入排序；然后逐渐缩小 gap（如 gap=gap/3+1），重复子序列排序过程；当 gap=1 时，整个序列被视为一个子序列，进行最后一次插入排序，此时序列已接近有序，插入排序效率极高。通过预排序减小序列无序程度，最终实现高效排序。



### 适用场景：

- 中等规模数据量的排序场景（优于插入排序、冒泡排序）。
- 对排序效率有一定要求，但数据量未达到需要快速排序 / 归并排序的场景。
- 不要求排序稳定性的场景（希尔排序是不稳定排序）。



### 优势劣势：

- 优势：相比直接插入排序，对中等规模数据效率更高（时间复杂度约为 O (N^1.3)）；原地排序，空间复杂度为 O (1)。
- 劣势：排序不稳定；增量序列的选择影响效率（目前无最优增量序列）；实现相对插入排序更复杂。



### 示例图:

![img](./assets/93fae629acfc03414c2645e4c160ff01.gif)



### 排序步骤:

1.先选定一个小于N的整数gap作为第一增量(通常取N/2)，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再gap--(通常是gap=gap/2)，重复上述操作。

2.当gap==1时就是直接插入排序，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。



### 总结:

![image-20250904150842837](./assets/image-20250904150842837.png)



### 示例代码:

```c
// 希尔排序函数
// 参数：a-待排序数组的指针，n-数组元素个数
void ShellSort(int* a, int n)
{
    // 初始化增量gap为数组长度，后续逐渐缩小
    int gap = n;
    // 当gap > 1时进行预排序，gap = 1时进行最后一次插入排序（完成排序）
    while (gap > 1)
    {
        // 计算下一个增量（gap = gap/3 + 1确保最终gap能减到1）
        gap = gap / 3 + 1;
        // 对每个子序列进行插入排序（子序列由间隔为gap的元素组成）
        // i从gap开始，依次遍历未排序元素（每个元素是对应子序列的待插入元素）
        for (int i = gap; i < n; i++)
        {
            // 若当前元素小于其所在子序列中前一个元素（间隔gap的元素），则需要插入
            if (a[i] < a[i - gap])
            {
                int tmp = a[i];  // 暂存待插入元素
                int j;
                // 在子序列中向前查找插入位置（步长为gap）
                for (j = i - gap; j >= 0 && a[j] > tmp; j -= gap)
                {
                    a[j + gap] = a[j];  // 子序列中元素后移，腾出位置
                }
                // 将待插入元素放入正确位置
                a[j + gap] = tmp;
            }
        }
    }
}
```

```python
# 希尔排序  O(n^2)/O(n^1.3)
def shell_sort(list):
    list = [0] + list
    n = len(list)
    d = n // 2  # 初始步长
    # list[0］只是暂存单元，不是哨兵，当j<=0时，插入位置已到
    while d >= 1:
        for i in range(d + 1, n):
            if list[i] < list[i - d]:  # 需将A[i]插入有序增量子表
                list[0] = list[i]  # 暂存在A[0]
                j = i - d
                while j > 0 and list[0] < list[j]:
                    list[j + d] = list[j]  # 记录后移，查找插入的位置
                    j -= d
                list[j + d] = list[0]  # 插入
        d = d // 2  # 步长变化
    return list[1:]


# 测试代码
if __name__ == '__main__':
    list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print("希尔排序前: ", list)
    print("希尔排序后: ", shell_sort(list))

```





## 堆排序

### 认识堆

  **1.什么是堆？**

​     **大堆：**父亲大于儿子   

​     **小堆：**父亲小于儿子（父亲，儿子是二叉树的概念）

  **2.堆的物理结构和逻辑结构？**

​     **物理结构：**数组     

​     **逻辑结构：**完全二叉树



### 算法解释：

堆排序是利用堆（完全二叉树的一种）这种数据结构设计的排序算法。其核心思想是：首先将待排序数组构建成一个大顶堆（或小顶堆），此时堆顶元素为最大值（或最小值）；将堆顶元素与堆尾元素交换，此时最大值（或最小值）被放置到数组末尾；然后对剩余元素重新调整为大顶堆（或小顶堆），重复交换和调整过程，直到整个数组有序。通过堆的特性高效筛选出最大 / 小元素，实现排序。



### 适用场景：

- 需要找出最大 / 最小元素的场景（堆排序可高效获取极值）。
- 中等至大规模数据排序场景（时间复杂度为 O (nlogn)）。
- 不要求排序稳定性的场景（堆排序是不稳定排序）。
- 内存受限的场景（原地排序，空间复杂度为 O (1)）。



### 优势劣势：

- 优势：时间复杂度稳定为 O (nlogn)（不受数据分布影响）；原地排序，空间效率高；适合处理大量数据。
- 劣势：排序不稳定；对缓存不友好（元素访问跳跃性大）；构建堆和调整堆的过程实现相对复杂。



### 步骤:

**堆排序包括建堆（向下调整+循环） 堆排序（交换+向下调整）**

 **1.建堆：**

​    要建大堆，堆顶的元素和最后一个数交换，然后把size--，就不会破坏堆的结构

 **2.向下调整算法：**

​    比较两个孩子的大小，选出大的孩子，与父亲比较，如果孩子大于父亲，交换。然后把parent=child，child=parent*2+1；向下调整算法一共会调整h-1次



### 示例图:

![img](./assets/f81018d0dccacef5e724a0c54499d3cc.gif)



### 总结:

![image-20250904151157340](./assets/image-20250904151157340.png)



### 示例代码:

```c
// 向下调整算法：将以root为根的子树调整为大顶堆
// 参数：a-数组指针，n-数组元素个数（堆的大小），root-当前需要调整的根节点索引
void AdjustDown(int* a, int n, int root)
{
    int parent = root;  // 记录当前父节点索引
    // 左孩子索引 = 父节点索引*2 + 1（完全二叉树性质）
    int child = parent * 2 + 1;
    
    // 当孩子索引小于堆的大小（未超出范围）时，继续调整
    while (child < n)
    {
        // 若右孩子存在且右孩子值大于左孩子，选择右孩子进行比较
        if (child + 1 < n && a[child] < a[child + 1])
        {
            child += 1;  // 切换到右孩子
        }
        
        // 若孩子值大于父节点值，交换两者（维护大顶堆性质）
        if (a[child] > a[parent])
        {
            swap(&a[child], &a[parent]);  // 交换函数复用之前的swap
            parent = child;  // 更新父节点为当前孩子节点
            child = parent * 2 + 1;  // 计算新的左孩子索引
        }
        else
        {
            // 若孩子值小于等于父节点，说明已满足大顶堆性质，退出调整
            break;
        }
    }
}
 
// 堆排序函数
// 参数：arr-待排序数组指针，n-数组元素个数
void HeapSort(int* arr, int n)
{
    // 步骤1：建大顶堆（从最后一个非叶子节点开始向前调整）
    // 最后一个非叶子节点索引 = (最后一个元素索引 - 1) / 2 = (n-1-1)/2
    for (int i = (n - 1 - 1) / 2; i >= 0; i--)
    {
        AdjustDown(arr, n, i);  // 对每个非叶子节点进行向下调整
    }
    
    // 步骤2：排序（循环取出堆顶最大值，放到数组末尾）
    for (int i = n; i > 1; i--)
    {
        // 交换堆顶（最大值）和当前堆的最后一个元素
        swap(&arr[0], &arr[i - 1]);
        // 对剩余的i-1个元素重新调整为大顶堆（堆大小变为i-1）
        AdjustDown(arr, i - 1, 0);
    }
}
```

```python
# 建立大根堆
def build_max_heap(list, len):
    for i in range(len // 2, 0, -1):  # 从后往前调整所有非终端节点
        head_adjust(list, i, len)


# 将以k为根的子树调整为大根堆
def head_adjust(list, k, len):
    list[0] = list[k]  # list[0]暂存子树的根节点
    i = 2 * k
    while i <= len:  # 沿key较大的子结点向下筛选
        if i < len and list[i] < list[i + 1]:
            i += 1  # 取key较大的子结点的下标
        if list[0] >= list[i]:
            break  # 筛选结束
        else:
            list[k] = list[i]  # 将A[i]调整到双亲结点上
            k = i  # 修改k值，以便继续向下筛选
        i *= 2
    list[k] = list[0]  # 被筛选结点的值放入最终位置


# 堆排序的主题函数  时间 O(nlog2n)
def heap_sort(list):
    length = len(list)  # 元素个数
    list = [0] + list
    build_max_heap(list, length)  # 初始建堆  O(n)
    for i in range(length, 0, -1):  # n-1趟的交换和建堆过程  O(nlog2n)
        list[i], list[1] = list[1], list[i]  # 把堆顶元素和堆底元素互换
        head_adjust(list, 1, i - 1)  # 把剩余待排元素整理成堆
    return list[1:]


# 测试代码
if __name__ == '__main__':
    list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print(heap_sort(list))
    print("堆排序前: ", list)
    print("堆排序后: ", heap_sort(list))

```





## 快速排序

### 排序方式:

**三种快排方法：**（一定要自己尝试着去写，会有一些坑，自己写才可以体会）

1.挖坑法

2.左右指针法

3.前后指针法



### 算法解释：

快速排序是一种分治法思想的排序算法，核心思想是：选择一个 “基准值（key）”，通过一趟排序将序列分为两部分，其中左部分元素均小于等于基准值，右部分元素均大于等于基准值（即基准值被放到最终位置）；然后递归地对左右两部分分别进行快速排序，直到子序列长度为 1 或 0，此时整个序列有序。通过分治减少问题规模，实现高效排序。



### 适用场景：

- 大规模数据排序场景（平均时间复杂度为 O (nlogn)）。
- 对排序效率要求较高的场景（实际应用中快排通常是最快的排序算法之一）。
- 不要求排序稳定性的场景（快排是不稳定排序）。
- 数据随机分布的场景（最坏情况可通过优化避免）。



### 优势劣势：

- 优势：平均时间复杂度低（O (nlogn)）；缓存友好（局部性好）；原地排序（空间复杂度为 O (logn)，递归栈开销）；实际应用中效率高。
- 劣势：最坏时间复杂度为 O (N²)（可通过三数取中法等优化）；不稳定排序；递归实现可能导致栈溢出（可改为非递归）。



### 挖坑法:

**1.思想：**

​    记第一个数为key，要调整key的位置，使得左边的都要比key的小，右边的数都比key的大。

​    选出一个数据（一般是最左边或是最右边的）存放在key变量中，在该数据位置形成一个坑
​    还是定义一个left和一个right，left从左向右走（当遇到大于key的值时停下来）。right从右向左走（当遇到小于key的值时停下来）。（若在最左边挖坑，则需要right先走；若在最右边挖坑，则需要left先走） 

​    把right的那个小的数放在坑中，在把left那个位置的值放在right那个位置中

​    重复操作，直到left>right时结束，完成一趟，把key放在了正确的位置

​    最后用分治思想，分成左边和右边，递归。



**3.示例图：**

![img](./assets/ba616900a5db7f10dee0484bb5ca393d.gif)



**4.示例代码：**

```c
// 1.挖坑法的快速排序
// 参数：a-待排序数组指针，left-当前排序区间左边界，right-当前排序区间右边界
void QuickSort(int* a, int left, int right)
{
    // 递归终止条件：当左边界大于等于右边界时，子序列长度为0或1，无需排序
    if (left >= right)
    {
        return;
    }
    
    int begin = left, end = right;
    int key = a[begin];  // 选取区间第一个元素作为基准值（挖坑）
    int pivot = begin;   // 记录坑的位置（初始为基准值位置）
    
    // 当左右指针未相遇时，继续调整
    while (begin < end)
    {
        // 从右向左找小于key的元素（填左边的坑）
        // 注意：必须先移动右指针（因基准值在左，需右指针先找小元素）
        while (begin < end && a[end] >= key)
        {
            end--;  // 右指针左移，直到找到小于key的元素
        }
        // 将找到的小元素填入当前坑中，同时该元素位置成为新坑
        a[pivot] = a[end];
        pivot = end;
        
        // 从左向右找大于key的元素（填右边的坑）
        while (begin < end && a[begin] <= key)
        {
            begin++;  // 左指针右移，直到找到大于key的元素
        }
        // 将找到的大元素填入当前坑中，同时该元素位置成为新坑
        a[pivot] = a[begin];
        pivot = begin;
    }
    
    // 当begin == end时，将基准值填入最终坑中（基准值归位）
    a[pivot] = key;
    
    // 递归排序左子区间[left, pivot-1]和右子区间[pivot+1, right]
    QuickSort(a, left, pivot - 1);
    QuickSort(a, pivot + 1, right);
}
```

```python
def quick_sort_hole(arr, left, right):
    """
    挖坑法快速排序
    :param arr: 待排序数组
    :param left: 左边界索引
    :param right: 右边界索引
    """
    # 递归终止条件：左右边界相遇或交叉
    if left >= right:
        return
    
    # 初始化指针和基准值（坑）
    begin, end = left, right
    # 取最左元素作为初始基准值，形成第一个坑
    pivot_value = arr[begin]
    pivot_index = begin  # 记录当前坑的位置
    
    while begin < end:
        # 从右向左找小于基准值的元素，填充到左边的坑
        while begin < end and arr[end] >= pivot_value:
            end -= 1
        # 将找到的小元素放入坑中，形成新的坑
        arr[pivot_index] = arr[end]
        pivot_index = end
        
        # 从左向右找大于基准值的元素，填充到右边的坑
        while begin < end and arr[begin] <= pivot_value:
            begin += 1
        # 将找到的大元素放入坑中，形成新的坑
        arr[pivot_index] = arr[begin]
        pivot_index = begin
    
    # 基准值放入最终的坑中
    arr[pivot_index] = pivot_value
    
    # 递归处理左子数组和右子数组
    quick_sort_hole(arr, left, pivot_index - 1)
    quick_sort_hole(arr, pivot_index + 1, right)
```



### 左右指针法:

**1.思路：**
1、选出一个key，一般是最左边或是最右边的。
2、定义一个begin和一个end，begin从左向右走，end从右向左走。（需要注意的是：若选择最左边的数据作为key，则需要end先走；若选择最右边的数据作为key，则需要bengin先走）（考虑到最后的时候相遇点的和key交换）。
3、在走的过程中，若end遇到小于key的数，则停下，begin开始走，直到begin遇到一个大于key的数时，将begin和right的内容交换，end再次开始走，如此进行下去，直到begin和end最终相遇，此时将相遇点的内容与key交换即可。（选取最左边的值作为key）
4.此时key的左边都是小于key的数，key的右边都是大于key的数
5.将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时



**2.示例图:**

![img](./assets/8fbca9b2fbc89695ca1a7493fbfa87f3.gif)



**3.示例代码:**

```c
// 交换两个整数的值（复用之前的swap函数，此处声明以避免报错）
void Swap(int* a, int* b);

// 2.左右指针法的快速排序
// 参数：a-待排序数组指针，left-当前排序区间左边界，right-当前排序区间右边界
void QuickSort(int* a, int left, int right)
{
    // 递归终止条件：子序列长度为0或1时无需排序
    if (left >= right)
    {
        return;
    }
    
    int begin = left, end = right;
    int key = begin;  // 选取左边界元素作为基准值（记录索引而非值）
    
    // 当左右指针未相遇时，继续调整
    while (begin < end)
    {
        // 右指针左移：找小于基准值的元素
        while (begin < end && a[end] >= a[key])
        {
            end--;
        }
        // 左指针右移：找大于基准值的元素
        while (begin < end && a[begin] <= a[key])
        {
            begin++;
        }
        // 交换左右指针指向的元素（小元素左移，大元素右移）
        Swap(&a[begin], &a[end]);
    }
    
    // 左右指针相遇后，交换基准值与相遇点元素（基准值归位）
    Swap(&a[begin], &a[key]);
    
    // 递归排序左子区间和右子区间
    QuickSort(a, left, begin - 1);
    QuickSort(a, begin + 1, right);
}

// 交换函数实现
void Swap(int* a, int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

```python
def quick_sort_double_pointer(arr, left, right):
    """
    左右指针法快速排序
    :param arr: 待排序数组
    :param left: 左边界索引
    :param right: 右边界索引
    """
    if left >= right:
        return
    
    # 初始化指针和基准值索引
    begin, end = left, right
    pivot_index = begin  # 以最左元素为基准值
    
    while begin < end:
        # 右指针向左找小于基准值的元素
        while begin < end and arr[end] >= arr[pivot_index]:
            end -= 1
        # 左指针向右找大于基准值的元素
        while begin < end and arr[begin] <= arr[pivot_index]:
            begin += 1
        # 交换左右指针找到的元素
        arr[begin], arr[end] = arr[end], arr[begin]
    
    # 将基准值放到最终位置（指针相遇点）
    arr[pivot_index], arr[begin] = arr[begin], arr[pivot_index]
    
    # 递归处理左右子数组
    quick_sort_double_pointer(arr, left, begin - 1)
    quick_sort_double_pointer(arr, begin + 1, right)
```



### 前后指针法：

**1.思路：**
1、选出一个key，一般是最左边。
2、起始时，prev指针指向序列开头，cur指针指向prev+1。
3、让cur一直向前走，当遇到小于a[key]时，让prev向前走一格（这个值一定大于a[key]，因为是cur走过的），然后a[cur]和a[prev]交换。

经过一次单趟排序，最终也能使得key左边的数据全部都小于key，key右边的数据全部都大于key。

然后也还是将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去

用if(left>right)

{
    reurn;

}//跳出递归



**2.示例图:**

![img](./assets/a19f716829dfc860f76e11a8aa24955c.gif)



**3.示例代码:**

```c
// 交换函数（复用）
void swap(int* a, int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

// 三数取中法：从左、中、右三个位置选中间值作为基准值，优化有序数据的排序效率
// 参数：a-数组指针，left-左边界，right-右边界，返回中间值的索引
int GetMidIndex(int* a, int left, int right)
{
    int mid = (left + right) / 2;  // 计算中间位置索引
    // 比较左、中、右三个位置的值，返回中间值的索引
    if (a[mid] >= a[left])
    {
        if (a[mid] <= a[right])
            return mid;
        else
        {
            if (a[right] >= a[left])
                return right;
            else
                return left;
        }
    }
    else  // a[left] > a[mid]
    {
        if (a[right] >= a[left])
            return left;
        else
        {
            if (a[right] >= a[mid])
                return right;
            else
                return mid;
        }
    }
}
 
// 3.前后指针法的快速排序
// 参数：a-待排序数组指针，left-当前排序区间左边界，right-当前排序区间右边界
void QuickSort(int* a, int left, int right)
{
    // 递归终止条件：子序列长度为0或1时无需排序
    if (left >= right)
    {
        return;
    }
    
    // 三数取中优化：选择中间值作为基准值，避免有序数据导致的O(N²)复杂度
    int index = GetMidIndex(a, left, right);
    swap(&a[left], &a[index]);  // 将中间值交换到左边界，作为基准值
    
    int key = left;       // 基准值索引（左边界）
    int prev = left;      // 前指针（初始指向基准值）
    int cur = left + 1;   // 后指针（初始指向基准值后一个元素）
    
    // 后指针遍历整个区间
    while (cur <= right)
    {
        // 若当前元素小于基准值，前指针后移并交换前后指针元素
        if (a[cur] < a[key])
        {
            prev++;  // 前指针后移（指向一个大于基准值的元素）
            swap(&a[cur], &a[prev]);  // 交换后，小元素移到前指针位置
        }
        cur++;  // 后指针后移
    }
    
    // 遍历结束后，交换基准值与前指针元素（基准值归位）
    swap(&a[prev], &a[key]);
    
    // 递归排序左子区间和右子区间
    QuickSort(a, left, prev - 1);
    QuickSort(a, prev + 1, right);
}
```

```python
def quick_sort_pre_cur(arr, left, right):
    """
    前后指针法快速排序
    :param arr: 待排序数组
    :param left: 左边界索引
    :param right: 右边界索引
    """
    if left >= right:
        return
    
    # 初始化指针和基准值
    pivot_index = left  # 以最左元素为基准值
    prev = left         # 前指针
    cur = left + 1      # 后指针
    
    while cur <= right:
        # 若当前元素小于基准值，前指针后移并交换元素
        if arr[cur] < arr[pivot_index]:
            prev += 1
            arr[prev], arr[cur] = arr[cur], arr[prev]
        cur += 1  # 后指针始终后移
    
    # 将基准值放到最终位置（前指针位置）
    arr[pivot_index], arr[prev] = arr[prev], arr[pivot_index]
    
    # 递归处理左右子数组
    quick_sort_pre_cur(arr, left, prev - 1)
    quick_sort_pre_cur(arr, prev + 1, right)
```



### 优化快排

**1.思路:**

三数取中法：取左端、中间、右端三个数，然后进行比较，将中值数当做key

否则有序时时间复杂度为O(N^2)

三数取中法可以套入三种方法中，这里我就写一种

```c
//三数取中
int GetMidIndex(int* a, int left, int right)
{
	int mid = (left + right) / 2;
	if (a[mid] >= a[left])
	{
		if (a[mid] <= a[right])
		{
			return mid;
		}
		else
		{
			if (a[right] >= a[left])
			{
				return right;
			}
			else
			{
				return left;
			}
		}
	}
	else//a[left]>a[mid]
	{
		if (a[right] >= a[left])
		{
			return left;
		}
		else
		{
			if (a[right] >= a[mid])
			{
				return right;
			}
			else
			{
				return mid;
			}
		}
	}
}
 
//交换
void swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
 
//前后指针法
void QuickSort(int* a, int left,int right)
{
	if (left >= right)
	{
		return;
	}
	int index=GetMidIndex(a,left, right);
	swap(&a[left], &a[index]);
	int key = left;
	int prev = left;
	int cur = left+1;
	while (cur <= right)
	{
		if (a[cur] < a[key])
		{
			prev++;
			swap(&a[cur], &a[prev]);
		}
		cur++;
	}
	swap(&a[prev], &a[key]);
	QuickSort(a, left, prev - 1);
	QuickSort(a, prev+1,right);
}
```

```python
def get_mid_index(arr, left, right):
    """
    三数取中法：选择左、中、右三个位置的中间值作为基准值
    用于优化快速排序，避免在有序数组上的退化
    :param arr: 数组
    :param left: 左边界
    :param right: 右边界
    :return: 中间值的索引
    """
    mid = (left + right) // 2  # 中间位置索引
    
    # 比较三个位置的值，返回中间值的索引
    if arr[left] <= arr[mid] <= arr[right] or arr[right] <= arr[mid] <= arr[left]:
        return mid
    elif arr[mid] <= arr[left] <= arr[right] or arr[right] <= arr[left] <= arr[mid]:
        return left
    else:
        return right

def quick_sort_optimized(arr, left, right):
    """
    优化版快速排序（三数取中法选择基准值）
    :param arr: 待排序数组
    :param left: 左边界索引
    :param right: 右边界索引
    """
    if left >= right:
        return
    
    # 三数取中选择基准值，并与左边界交换
    mid_index = get_mid_index(arr, left, right)
    arr[left], arr[mid_index] = arr[mid_index], arr[left]
    
    # 使用前后指针法进行排序（也可替换为其他两种方法）
    pivot_index = left
    prev = left
    cur = left + 1
    
    while cur <= right:
        if arr[cur] < arr[pivot_index]:
            prev += 1
            arr[prev], arr[cur] = arr[cur], arr[prev]
        cur += 1
    
    arr[pivot_index], arr[prev] = arr[prev], arr[pivot_index]
    
    # 递归处理子数组
    quick_sort_optimized(arr, left, prev - 1)
    quick_sort_optimized(arr, prev + 1, right)
```



### 总结:

![image-20250904151007656](./assets/image-20250904151007656.png)



### python快排示例代码:

```python
# 快速排序  O(nlogn)
# 快排划分函数 用第一个元素将待排序序列划分成左右两个部分
def partition(list, low, high):
    pivot = list[low]  # 第一个元素作为枢轴
    while (low < high):  # 用Low、high搜索枢轴的最终位置
        while (low < high and list[high] >= pivot):
            high -= 1
        list[low] = list[high]  # 比枢轴小的元素移动到左端
        while (low < high and list[low] <= pivot):
            low += 1
        list[high] = list[low]  # 比枢轴大的元素移动到右端
    list[low] = pivot  # 枢轴元素存放到最终位置
    return low  # 返回存放枢轴的最终位置


# 快排主体函数
def quick_sort(list, low, high):
    if (low < high):  # 递归跳出的条件
        pivotpos = partition(list, low, high)  # 划分左右子表
        quick_sort(list, low, pivotpos - 1)  # 递归排序左子表
        quick_sort(list, pivotpos + 1, high)  # 递归排序右子表
    return list


# 测试代码
if __name__ == '__main__':
    list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print("快速排序前: ", list)
    print("快速排序后: ", quick_sort(list, 0, len(list) - 1))

```





## 归并排序

### **思路：**

1.不断的分割数据，让数据的每一段都有序（一个数据相当于有序）

2.当所有子序列有序的时候，在把子序列归并，形成更大的子序列，最终整个数组有序。



### 算法解释：

归并排序是基于分治法的排序算法，核心思想是：将待排序序列不断二分，直到每个子序列只包含一个元素（此时子序列天然有序）；然后将两个有序子序列合并为一个更大的有序子序列，重复合并过程，直到最终得到一个完整的有序序列。合并过程通过比较两个子序列的元素，按顺序放入临时空间实现。



### 适用场景：

- 大规模数据排序场景（时间复杂度稳定为 O (nlogn)）。
- 对排序稳定性有要求的场景（归并排序是稳定排序）。
- 外部排序（数据无法全部加载到内存，需分批处理）场景。
- 链表排序（归并排序对链表效率高，无需大量移动元素）。



### 优势劣势：

- 优势：时间复杂度稳定为 O (nlogn)（不受数据分布影响）；稳定排序；适合处理大量数据和外部排序。
- 劣势：需要额外的存储空间（空间复杂度为 O (n)）；递归实现可能有栈开销；对小规模数据效率不如插入排序。



### 注意:

 需要开一个_MergeSort,而不是直接在MergeSort中直接递归，是因为MergeSort中有一个malloc

 归并排序很像二叉树中的后序思想，先递归，递归到最后的时候再合并。



### 示例图:

![img](./assets/20bca66489ea8615dfa2c44c05820c4f.png)

![img](./assets/17847222181095acdab5c4a31b307b16.gif)



### 总结:

![image-20250904151244439](./assets/image-20250904151244439.png)



### 示例代码:

```c
// 归并排序的辅助函数：递归实现子序列排序与合并
// 参数：a-待排序数组指针，left-当前区间左边界，right-当前区间右边界，tmp-临时数组指针（用于合并）
void _MergeSort(int* a, int left, int right, int* tmp)
{
    // 递归终止条件：当左边界大于等于右边界时，子序列长度为0或1（已有序）
    if (left >= right)
    {
        return;
    }
    
    // 二分当前区间为左右两个子区间
    int mid = (left + right) >> 1;  // 等价于(left + right)/2，效率更高
    
    // 递归排序左子区间[left, mid]和右子区间[mid+1, right]
    _MergeSort(a, left, mid, tmp);
    _MergeSort(a, mid + 1, right, tmp);
    
    // 合并两个有序子区间
    int begin1 = left, end1 = mid;       // 左子区间的起止索引
    int begin2 = mid + 1, end2 = right;  // 右子区间的起止索引
    int i = left;                        // 临时数组的当前填充索引
    
    // 比较两个子区间的元素，按顺序放入临时数组
    while (begin1 <= end1 && begin2 <= end2)
    {
        if (a[begin1] <= a[begin2])  // 左子区间元素较小，放入临时数组
        {
            tmp[i++] = a[begin1++];
        }
        else  // 右子区间元素较小，放入临时数组
        {
            tmp[i++] = a[begin2++];
        }
    }
    
    // 将左子区间剩余元素放入临时数组
    while (begin1 <= end1)
    {
        tmp[i++] = a[begin1++];
    }
    
    // 将右子区间剩余元素放入临时数组
    while (begin2 <= end2)
    {
        tmp[i++] = a[begin2++];
    }
    
    // 将临时数组中合并好的有序元素复制回原数组
    for (int j = left; j <= right; j++)
    {
        a[j] = tmp[j];
    }
}

// 归并排序主函数
// 参数：a-待排序数组指针，n-数组元素个数
void MergeSort(int* a, int n)
{
    // 分配临时数组（用于合并过程，避免递归中重复分配）
    int* tmp = (int*)malloc(sizeof(int) * n);
    if (tmp == NULL)  // 内存分配失败处理
    {
        // 实际应用中可添加错误处理逻辑
        return;
    }
    
    // 调用辅助函数进行递归排序
    _MergeSort(a, 0, n - 1, tmp);
    
    // 释放临时数组
    free(tmp);
    tmp = NULL;
}
```

```python
# 建立大根堆
def build_max_heap(list, len):
    for i in range(len // 2, 0, -1):  # 从后往前调整所有非终端节点
        head_adjust(list, i, len)


# 将以k为根的子树调整为大根堆
def head_adjust(list, k, len):
    list[0] = list[k]  # list[0]暂存子树的根节点
    i = 2 * k
    while i <= len:  # 沿key较大的子结点向下筛选
        if i < len and list[i] < list[i + 1]:
            i += 1  # 取key较大的子结点的下标
        if list[0] >= list[i]:
            break  # 筛选结束
        else:
            list[k] = list[i]  # 将A[i]调整到双亲结点上
            k = i  # 修改k值，以便继续向下筛选
        i *= 2
    list[k] = list[0]  # 被筛选结点的值放入最终位置


# 堆排序的主题函数  时间 O(nlog2n)
def heap_sort(list):
    length = len(list)  # 元素个数
    list = [0] + list
    build_max_heap(list, length)  # 初始建堆  O(n)
    for i in range(length, 0, -1):  # n-1趟的交换和建堆过程  O(nlog2n)
        list[i], list[1] = list[1], list[i]  # 把堆顶元素和堆底元素互换
        head_adjust(list, 1, i - 1)  # 把剩余待排元素整理成堆
    return list[1:]


# 测试代码
if __name__ == '__main__':
    list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    print(heap_sort(list))
    print("堆排序前: ", list)
    print("堆排序后: ", heap_sort(list))

```





## 桶排序

### 思路:

*大问题化小*

**桶排序 (Bucket sort)**或所谓的**箱排序**，是一种分块的[排序算法](https://baike.baidu.com/item/排序算法/5399605)，工作的原理是将数组分到有限数量的桶里，每个桶的大小都相等。每个桶再个别排序（有可能再使用别的[排序算法](https://baike.baidu.com/item/排序算法/5399605)或是以递归方式继续使用[桶排序](https://so.csdn.net/so/search?q=桶排序&spm=1001.2101.3001.7020)进行排序）

把待排序序列（数组）中的数据根据函数映射方法分配到若干个桶中，在分别对各个桶进行排序，最后依次按顺序取出桶中的数据。
适用于数据分配均匀，数据比较大，相对集中的情况。



### 算法解释：

桶排序是一种分布式排序算法，核心思想是：将待排序数据根据预设的映射函数分配到多个 “桶” 中（每个桶对应一个数据范围）；对每个非空桶单独进行排序（可使用其他排序算法或递归桶排序）；最后按桶的顺序依次将所有桶中的元素取出，组成有序序列。通过将数据分散到多个桶中，降低单个桶的排序规模，提高整体效率。



### 适用场景：

- 数据分布均匀的场景（如年龄、成绩等在一定范围内均匀分布的数据）。
- 数据范围较大但可映射到有限桶的场景。
- 对排序效率要求较高的场景（平均时间复杂度为 O (n + k)，n 为数据量，k 为桶数）。



### 优势劣势：

- 优势：当数据分布均匀时，效率极高（接近线性时间）；可并行化处理（每个桶独立排序）。
- 劣势：对数据分布敏感（分布不均时效率下降）；需要额外存储空间（存储桶）；不适用于离散度过大的数据。



### 示例代码:

```c
#include <stdio.h>
#include <stdlib.h>

// 定义桶中节点的结构（链表形式存储桶内元素）
typedef struct KeyNode {
    int num;           // 存储的数据
    struct KeyNode* next;  // 指向下一个节点的指针
} KeyNode;

// 桶排序函数
// 参数：a-待排序数组，size-数组元素个数，bucket_size-桶的数量
void bucket_sort(int a[], int size, int bucket_size) {
    int i, j;
    // 动态分配桶数组（每个元素是指向桶头节点的指针）
    KeyNode** bucket_num = (KeyNode**)malloc(bucket_size * sizeof(KeyNode*));
    if (bucket_num == NULL) {
        printf("内存分配失败\n");
        return;
    }
    
    // 初始化每个桶（创建头节点，用于标识桶和记录元素数量）
    for (i = 0; i < bucket_size; i++) {
        bucket_num[i] = (KeyNode*)malloc(sizeof(KeyNode));
        if (bucket_num[i] == NULL) {
            printf("内存分配失败\n");
            return;
        }
        bucket_num[i]->num = 0;    // 记录桶内元素数量（初始为0）
        bucket_num[i]->next = NULL; // 桶内初始无元素
    }
    
    // 将数组元素分配到对应的桶中
    for (j = 0; j < size; j++) {
        // 创建新节点存储当前元素
        KeyNode* node = (KeyNode*)malloc(sizeof(KeyNode));
        if (node == NULL) {
            printf("内存分配失败\n");
            return;
        }
        node->num = a[j];    // 存储数据
        node->next = NULL;   // 初始指向空
        
        // 计算当前元素应放入的桶索引（映射函数：假设数据范围适合a[j]/100）
        int index = a[j] / 100;
        // 确保索引不超出桶的范围（容错处理）
        if (index >= bucket_size) {
            index = bucket_size - 1;
        }
        
        // 桶内采用插入排序：将新节点插入到正确位置，保持桶内有序
        KeyNode* p = bucket_num[index];  // p指向桶的头节点
        // 找到插入位置（前一个节点的值 <= 当前节点值 <= 后一个节点值）
        while (p->next != NULL && p->next->num <= node->num) {
            p = p->next;
        }
        // 插入新节点到p和p->next之间
        node->next = p->next;
        p->next = node;
        bucket_num[index]->num++;  // 桶内元素数量加1
    }
    
    // 打印排序结果（按桶顺序依次输出桶内元素）
    KeyNode* k = NULL;
    for (i = 0; i < bucket_size; i++) {
        k = bucket_num[i]->next;  // 指向桶内第一个有效元素
        // 遍历桶内所有元素并打印
        for (int m = 0; m < bucket_num[i]->num; m++) {
            printf("%d ", k->num);
            k = k->next;
        }
    }
    printf("\n");
    
    // 释放内存（实际应用中需释放所有节点，此处简化）
    // ...
}
```

```python
def bucket_sort(arr, num_buckets=10):
    """桶排序：适用于均匀分布的浮点数或整数，时间复杂度O(n + k)"""
    if not arr:
        return arr

    # 创建空桶
    buckets = [[] for _ in range(num_buckets)]

    # 确定数据范围
    min_val = min(arr)
    max_val = max(arr)
    range_val = max_val - min_val

    # 将元素分配到不同的桶中
    for num in arr:
        # 计算桶索引，处理range_val为0的特殊情况
        if range_val == 0:
            bucket_index = 0
        else:
            bucket_index = int((num - min_val) * (num_buckets - 1) / range_val)
        buckets[bucket_index].append(num)

    # 对每个桶进行排序（这里使用内置排序，也可以递归使用桶排序）
    for i in range(num_buckets):
        buckets[i].sort()

    # 合并所有桶的结果
    return [num for bucket in buckets for num in bucket]


# 测试代码
if __name__ == "__main__":
    arr2 = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
    print("桶排序前:", arr2)
    print("桶排序后:", bucket_sort(arr2))

```





## 计数排序

### 特点:

一种特殊的排序，唯一种没有比较的排序（指没有前后比较，还是有交换的）



### 思路:

以数组的下标当做数值，有这个数的时候a[i]++;

![img](./assets/45ab0354442c067c3fc0814100c3fca4.png)

 **局限：**适用于整数。数要求集中（否则空间的浪费大）



### 算法解释：

计数排序是一种非比较型排序算法，核心思想是：通过统计待排序数据中每个元素的出现次数，确定每个元素在最终有序序列中的位置。具体来说，先找出数据的范围（最大值和最小值），创建一个计数数组记录每个元素的出现次数；再通过计数数组计算每个元素的前缀和（确定元素的起始位置）；最后反向遍历原数组，将元素放入其在结果数组中的对应位置。



### 适用场景：

- 数据为整数且范围不大的场景（如年龄、成绩等）。
- 对排序稳定性有要求的场景（计数排序是稳定排序）。
- 数据重复度高的场景（可高效压缩存储空间）。



### 优势劣势：

- 优势：时间复杂度为 O (n + k)（n 为数据量，k 为数据范围），效率极高；稳定排序；无比较操作。
- 劣势：仅适用于整数；对数据范围敏感（k 过大时空间复杂度高）；需要额外存储空间。



### 绝对映射：

![img](./assets/d1c44becef9d4d22e6ae62b712db4a66.png)

```c
int * countingSort1(int arr[],int count,int max) {
    int index = 0;
    int *tmpArr = (int *)malloc(max*sizeof(int));
    int *result = (int *)malloc(max*sizeof(int));
    
    for(int k = 0;k<max;k++) {
        tmpArr[k] = 0;
    }
    
    for (int i = 0; i<count; i++) {
        tmpArr[arr[i]]++;
    }
    for (int j = 0; j<max; j++) {
        while (tmpArr[j]) {
            result[index++] = j;
            tmpArr[j]--;
        }
    }
    free(tmpArr);
    tmpArr = NULL;
    return result;
}
```



### 相对映射：

![img](./assets/8288b108f52d377eef696341beddfe27.png)

```c
void CountSort(int* a, int n)
{
	int max = a[0], min = a[0];
	for (int i = 0; i < n; i++)
	{
		if (a[i] > max) max = a[i];
		if (a[i] < min) min = a[i];
	}
	int range = max - min + 1;
	int* count = (int*)malloc(sizeof(int) * range);
	memset(count, 0, sizeof(int) * range);
	for (int i = 0; i < n; i++)
	{
		count[a[i] - min]++;
	}
	int i = 0;
	for (int j = 0; j < range; j++)
	{
		while (count[j]--)
		{
			a[i++] = j + min;
		}
	}
	free(count);
}
```



### python实现:

```python
def counting_sort(list):
    """计数排序：适用于整数排序，时间复杂度O(n+k)，其中k是数据范围"""
    if not list:
        return list

    # 找出数组中的最大值和最小值
    min_val = min(list)
    max_val = max(list)

    # 创建计数数组并统计每个元素的出现次数
    count_range = max_val - min_val + 1
    count = [0] * count_range
    for num in list:
        count[num - min_val] += 1

    # 计算前缀和，确定每个元素的位置
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # 构建输出数组
    output = [0] * len(list)
    # 从后往前遍历，保持稳定性
    for num in reversed(list):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1

    return output


# 测试代码
if __name__ == "__main__":
    arr1 = [4, 2, 2, 8, 3, 3, 1]
    print("计数排序前:", arr1)
    print("计数排序后:", counting_sort(arr1))

```



### 总结:

![image-20250904151446417](./assets/image-20250904151446417.png)





## 基数排序

### 原理:

原理：是将整数按位数切割成不同的数字，然后按每个位数分别比较。



### 算法解释：

基数排序是一种非比较型排序算法，核心思想是：将整数按位数从低到高（或从高到低）依次排序。对于每个位数（个位、十位、百位等），将所有数字按该位的值分配到 0-9 共 10 个桶中，然后按桶的顺序将数字取出，组成新的序列；重复此过程直到所有位数都处理完毕，序列即有序。通过按位分步排序，实现整体有序。



### 适用场景：

- 整数排序（可扩展到字符串、日期等有明确位数的类型）。
- 数据范围较大但位数有限的场景（如身份证号、电话号码等）。
- 对排序稳定性有要求的场景（基数排序是稳定排序）。



### 优势劣势：

- 优势：时间复杂度为 O (d*(n + k))（d 为位数，n 为数据量，k 为基数 10）；稳定排序；适用于大范围但位数有限的数据。
- 劣势：仅适用于整数或可按位处理的数据；需要额外存储空间（桶）；位数过多时效率下降。



### 示例图:

![img](./assets/792053044b35d4d7ea5eb05501c1606f.png)



### 总结:

![image-20250904151334369](./assets/image-20250904151334369.png)



### 示例代码:

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// 查找数组中的最大数（用于确定最大位数）
// 参数：p-数组指针，n-数组元素个数，返回最大值
int findMaxNum(int* p, int n)
{
    int i;
    int max = p[0];  // 初始假设第一个元素为最大
    for (i = 0; i < n; i++)
    {
        if (*(p + i) > max)
        {
            max = *(p + i);
        }
    }
    return max;
}

// 获取数字的位数（如123的位数为3）
// 参数：num-待计算位数的数字，返回位数
int getLoopTimes(int num)
{
    if (num == 0) return 1;  // 0的位数为1
    int count = 0;
    while (num != 0)
    {
        count++;
        num = num / 10;  // 每次除以10，减少一位
    }
    return count;
}

// 按当前位数（loop）对数组进行桶分配与合并
// 参数：p-数组指针，n-数组元素个数，loop-当前处理的位数（1-个位，2-十位等）
void sort2(int* p, int n, int loop)
{
    // 建立10个桶（每个桶最多存放20个元素，可根据实际情况调整）
    int buckets[10][20] = {0};  // 初始化为0
    // 计算当前位数的除数（如个位为1，十位为10，百位为100）
    int tempNum = (int)pow(10, loop - 1);
    
    // 将元素分配到对应桶中
    int i, j;
    for (i = 0; i < n; i++)
    {
        // 计算当前元素在当前位数上的值（0-9），作为桶索引
        int row_index = (*(p + i) / tempNum) % 10;
        // 找到桶中第一个空位置，放入元素
        for (j = 0; j < 20; j++)
        {
            if (buckets[row_index][j] == 0)  // 假设0为未使用的标志（需确保原数组无0，或修改标志）
            {
                buckets[row_index][j] = *(p + i);
                break;
            }
        }
    }
    
    // 将桶中的元素按顺序合并回原数组
    int k = 0;  // 原数组的当前填充索引
    for (i = 0; i < 10; i++)  // 遍历10个桶
    {
        for (j = 0; j < 20; j++)  // 遍历桶中元素
        {
            if (buckets[i][j] != 0)  // 若桶中该位置有元素
            {
                *(p + k) = buckets[i][j];
                buckets[i][j] = 0;  // 清空桶，便于下次使用
                k++;
            }
        }
    }
}

// 基数排序主函数
// 参数：p-待排序数组指针，n-数组元素个数
void bucketSort3(int* p, int n)
{
    if (n <= 1) return;  // 数组长度小于等于1时无需排序
    
    // 步骤1：获取数组中的最大数
    int maxNum = findMaxNum(p, n);
    // 步骤2：确定最大数的位数（即需要排序的轮次）
    int loopTimes = getLoopTimes(maxNum);
    
    // 步骤3：按每个位数依次排序
    for (int i = 1; i <= loopTimes; i++)
    {
        sort2(p, n, i);  // 按第i位排序
    }
}

// 测试函数
void testBS()
{
    int a[] = {2, 343, 342, 1, 123, 43, 4343, 433, 687, 654, 3};
    int* a_p = a;
    int size = sizeof(a) / sizeof(int);  // 计算数组长度
    
    bucketSort3(a_p, size);  // 执行基数排序
    
    // 打印排序结果
    int i;
    for (i = 0; i < size; i++)
    {
        printf("%d ", a[i]);
    }
    printf("\n");
}

// 主函数（用于测试）
int main()
{
    testBS();
    return 0;
}
```

```python
def radix_sort(arr):
    """基数排序：适用于整数排序，时间复杂度O(d*(n+k))，d是位数，k是基数"""
    if not arr:
        return arr

    # 找出数组中的最大值，确定最大位数
    max_val = max(arr)
    max_digits = len(str(abs(max_val)))

    # 处理负数，将所有数转为正数进行排序
    has_negative = any(num < 0 for num in arr)
    if has_negative:
        min_val = min(arr)
        offset = -min_val
        arr = [num + offset for num in arr]
        max_val += offset
    else:
        offset = 0

    # 基数为10（十进制）
    radix = 10
    for digit in range(max_digits):
        # 初始化10个桶
        buckets = [[] for _ in range(radix)]

        # 根据当前位的值将元素分配到桶中
        divisor = radix ** digit
        for num in arr:
            bucket_index = (num // divisor) % radix
            buckets[bucket_index].append(num)

        # 合并所有桶的结果
        arr = [num for bucket in buckets for num in bucket]

    # 如果有负数，还原偏移量
    if has_negative:
        arr = [num - offset for num in arr]

    return arr

# 测试代码
if __name__ == "__main__":
    arr3 = [170, 45, 75, 90, 802, 24, 2, 66, -123, -45]
    print("基数排序前:", arr3)
    print("基数排序后:", radix_sort(arr3))
```

